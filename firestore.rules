rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Spaces v1: enforcement aligns with SPACES_V1_PRODUCT_IA_SPEC.md scenario coverage.

    // ========================================
    // SECURITY HELPER FUNCTIONS
    // ========================================

    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function isAdmin() {
      return isAuthenticated() &&
        exists(/databases/$(database)/documents/admins/$(request.auth.uid));
    }

    function userCampusId() {
      // Single-expression style (no statements) for CLI compatibility
      // If unauthenticated → null; else use token.campusId with UB default
      return isAuthenticated()
        ? (request.auth.token.campusId != null ? request.auth.token.campusId : 'ub-buffalo')
        : null;
    }

    function isUBUser() {
      return isAuthenticated() &&
        (
          request.auth.token.email.matches('.*@buffalo[.]edu$') ||
          request.auth.token.campusId == 'ub-buffalo'
        );
    }

    function getUserCampus() {
      return userCampusId();
    }

    function campusMatches(campusId) {
      return userCampusId() != null && campusId == userCampusId();
    }

    function notTooFrequent() {
      return resource.data.updatedAt != null &&
        request.time > resource.data.updatedAt + duration.value(1, 's');
    }

    function getSpaceDoc(spaceId) {
      return get(/databases/$(database)/documents/spaces/$(spaceId));
    }

    function spaceExists(spaceId) {
      return exists(/databases/$(database)/documents/spaces/$(spaceId));
    }

    function getMemberRole(spaceData, memberId) {
      return spaceData.memberRoles == null ? null : spaceData.memberRoles[memberId];
    }

    function isSpaceMember(spaceData, memberId) {
      return getMemberRole(spaceData, memberId) != null;
    }

    function canPin(spaceData, memberId) {
      return getMemberRole(spaceData, memberId) == 'leader' || getMemberRole(spaceData, memberId) == 'admin';
    }

    function canModerate(spaceData, memberId) {
      return (
        getMemberRole(spaceData, memberId) == 'leader' ||
        getMemberRole(spaceData, memberId) == 'admin' ||
        getMemberRole(spaceData, memberId) == 'moderator'
      );
    }

    function memberMayPost(spaceData, memberId) {
      return (
        (spaceData.settings != null && spaceData.settings.postingPolicy == 'leaders_only')
          ? canPin(spaceData, memberId)
          : isSpaceMember(spaceData, memberId)
      );
    }

    function toolCanEdit(toolData, memberId) {
      return toolData.permissions != null &&
        toolData.permissions.canEdit != null &&
        toolData.permissions.canEdit.hasAny([memberId]);
    }

    function isLeaderForSpace(spaceId, memberId) {
      // Leaders/admins for a given space (null spaceId treated as true for authoring outside a space)
      return spaceId == null
        ? true
        : (spaceExists(spaceId) && (getSpaceDoc(spaceId).exists() && canPin(getSpaceDoc(spaceId).data(), memberId)));
    }

    function canAuthorTool(toolData, memberId) {
      return toolCanEdit(toolData, memberId) && isLeaderForSpace(toolData.spaceId, memberId);
    }

    function validAudience(audience) {
      return (
        (audience == null ? 'members' : audience) == 'members' ||
        (audience == null ? 'members' : audience) == 'campus' ||
        (audience == null ? 'members' : audience) == 'public'
      );
    }

    function validModerationStatus(status) {
      return (
        (status == null ? 'active' : status) == 'active' ||
        (status == null ? 'active' : status) == 'auto_hidden' ||
        (status == null ? 'active' : status) == 'escalated' ||
        (status == null ? 'active' : status) == 'removed'
      );
    }

    function validPinState(pinnedAt, pinExpiresAt) {
      return (pinnedAt == null && pinExpiresAt == null) ||
        (pinnedAt != null && (pinExpiresAt == null || pinExpiresAt > pinnedAt));
    }

    function postVisibleTo(spaceData, postData, memberId) {
      return postData != null &&
        validAudience(postData.audience) &&
        ((postData.moderationStatus == null ? 'active' : postData.moderationStatus) == 'active'
          ? true
          : canModerate(spaceData, memberId)) &&
        ((postData.audience == null ? 'members' : postData.audience) == 'members'
          ? isSpaceMember(spaceData, memberId)
          : true);
    }

    // ========================================
    // IDENTITY & ONBOARDING (PROFILES, SESSIONS, THROTTLE)
    // ========================================
    match /profiles/{profileId} {
      allow read, write: if false;

      match /settings/{settingId} {
        allow read, write: if false;
      }

      // Auto-connections and computed graphs — owner may read, no client writes
      match /connections/{otherId} {
        allow read: if isOwner(profileId);
        allow write: if false;
      }

      match /pendingConnections/{otherId} {
        allow read: if isOwner(profileId);
        allow write: if false;
      }

      match /suggestedConnections/{otherId} {
        allow read: if isOwner(profileId);
        allow write: if false;
      }
      // Friends and friendRequests — owner-only writes; accept allowed by target on incoming request; reads owner-only
      match /friends/{friendId} {
        allow read: if isOwner(profileId);
        allow create, update, delete: if isOwner(profileId);
      }

      match /friendRequests/{otherId} {
        allow read: if isOwner(profileId);
        // Owner can manage their requests; target can write acceptance on incoming
        allow create, update, delete: if isOwner(profileId);
      }
    }

    // Presence documents — campus-scoped reads with privacy + connections checks; owner-only writes
    function presenceReadableFor(profileId) {
      if (!isAuthenticated()) return false;
      if (isOwner(profileId)) return true;

      // Ghost mode hides presence from others
      if (resource.data.isGhostMode == true) return false;

      // Default privacy if settings missing: campus
      let visibility = 'campus';
      let allowMessages = true; // unused here; reserved for future
      let hasPrivacy = exists(/databases/$(database)/documents/profiles/$(profileId)/settings/privacy);
      if (hasPrivacy) {
        let privacyDoc = get(/databases/$(database)/documents/profiles/$(profileId)/settings/privacy);
        visibility = privacyDoc.data.visibility;
        allowMessages = privacyDoc.data.allowMessages == true;
      }

      // Connections-only helper
      function connectionExists(a, b) {
        return exists(/databases/$(database)/documents/profiles/$(a)/connections/$(b));
      }

      return (
        (visibility == 'public') ||
        (visibility == 'campus' && campusMatches(resource.data.campusId)) ||
        (visibility == 'connections' && connectionExists(profileId, request.auth.uid))
      );
    }

    match /presence/{profileId} {
      allow get, list: if presenceReadableFor(profileId);
      // Create: allow initial write without frequency guard
      allow create: if isOwner(profileId) &&
        request.resource.data.campusId != null && campusMatches(request.resource.data.campusId);
      // Update: throttle successive writes via notTooFrequent()
      allow update: if isOwner(profileId) &&
        request.resource.data.campusId != null && campusMatches(request.resource.data.campusId) &&
        notTooFrequent();
      allow delete: if false;
    }

    match /onboarding_progress/{profileId} {
      allow read, write: if false;
    }

    match /sessions/{sessionId} {
      allow read, write: if false;
    }

    match /auth_throttle/{throttleId} {
      allow read, write: if false;
    }

    match /auth_throttle_events/{eventId} {
      allow read, write: if false;
    }

    match /auth_events/{eventId} {
      allow read, write: if false;
    }

    // ========================================
    // TOOLS (HiveLab)
    // ========================================
    match /tools/{toolId} {
      allow get, list: if isAuthenticated() &&
        isUBUser() &&
        campusMatches(resource.data.campusId) &&
        (
          resource.data.visibility == 'campus' ||
          resource.data.visibility == 'public' ||
          resource.data.createdBy == request.auth.uid ||
          toolCanEdit(resource.data, request.auth.uid)
        );

      allow create: if isAuthenticated() &&
        isUBUser() &&
        campusMatches(request.resource.data.campusId) &&
        request.resource.data.createdBy == request.auth.uid &&
        request.resource.data.status == 'draft' &&
        (request.resource.data.visibility == null || request.resource.data.visibility == 'private') &&
        request.resource.data.permissions != null &&
        request.resource.data.permissions.canEdit != null &&
        request.resource.data.permissions.canEdit.hasAny([request.auth.uid]) &&
        isLeaderForSpace(request.resource.data.spaceId, request.auth.uid);

      allow update: if isAuthenticated() &&
        isUBUser() &&
        campusMatches(resource.data.campusId) &&
        request.resource.data.campusId == resource.data.campusId &&
        request.resource.data.createdBy == resource.data.createdBy &&
        request.resource.data.permissions != null &&
        request.resource.data.permissions.canEdit != null &&
        request.resource.data.permissions.canEdit.hasAny([request.auth.uid]) &&
        canAuthorTool(resource.data, request.auth.uid);

      allow delete: if false;
    }

    // ========================================
    // USER PROFILES
    // ========================================
    match /users/{userId} {
      // Users can only see other users from their campus
      allow read: if isAuthenticated() && (
        isOwner(userId) ||
        (resource.data.schoolId != null && campusMatches(resource.data.schoolId) && resource.data.isPublic != false)
      );

      allow write: if isOwner(userId) &&
        request.resource.data.schoolId != null &&
        campusMatches(request.resource.data.schoolId) &&
        notTooFrequent();
    }

    // ========================================
    // SPACES - CAMPUS ISOLATED
    // ========================================
    match /spaces/{spaceId} {
      allow read: if isAuthenticated() &&
        isUBUser() &&
        campusMatches(resource.data.campusId) &&
        resource.data.isActive == true &&
        (
          resource.data.visibility != 'private' ||
          (resource.data.memberRoles != null && resource.data.memberRoles[request.auth.uid] != null)
        );

      allow create: if isAuthenticated() &&
        isUBUser() &&
        campusMatches(request.resource.data.campusId) &&
        request.resource.data.memberRoles != null &&
        (
          request.resource.data.memberRoles[request.auth.uid] == 'leader' ||
          request.resource.data.memberRoles[request.auth.uid] == 'admin'
        ) &&
        request.resource.data.isActive == true;

      allow update: if isAuthenticated() &&
        isUBUser() &&
        campusMatches(resource.data.campusId) &&
        request.resource.data.campusId == resource.data.campusId &&
        canPin(resource.data, request.auth.uid);

      allow delete: if isAuthenticated() &&
        isUBUser() &&
        campusMatches(resource.data.campusId) &&
        canPin(resource.data, request.auth.uid);

      match /posts/{postId} {
        allow read: if isAuthenticated() &&
          isUBUser() &&
          spaceExists(spaceId) &&
          campusMatches(getSpaceDoc(spaceId).data.campusId) &&
          getSpaceDoc(spaceId).data.isActive == true &&
          resource.data.isDeleted != true &&
          postVisibleTo(getSpaceDoc(spaceId).data, resource.data, request.auth.uid);

        allow create: if isAuthenticated() &&
          isUBUser() &&
          spaceExists(spaceId) &&
          campusMatches(getSpaceDoc(spaceId).data.campusId) &&
          getSpaceDoc(spaceId).data.isActive == true &&
          memberMayPost(getSpaceDoc(spaceId).data, request.auth.uid) &&
          request.resource.data.authorId == request.auth.uid &&
          request.resource.data.spaceId == spaceId &&
          validAudience(request.resource.data.audience) &&
          validModerationStatus(request.resource.data.moderationStatus) &&
          validPinState(request.resource.data.pinnedAt, request.resource.data.pinExpiresAt) &&
          (
            request.resource.data.pinnedAt == null ||
            canPin(getSpaceDoc(spaceId).data, request.auth.uid)
          );

        allow update: if isAuthenticated() &&
          isUBUser() &&
          spaceExists(spaceId) &&
          campusMatches(getSpaceDoc(spaceId).data.campusId) &&
          getSpaceDoc(spaceId).data.isActive == true &&
          validAudience(request.resource.data.audience) &&
          validModerationStatus(request.resource.data.moderationStatus) &&
          validPinState(request.resource.data.pinnedAt, request.resource.data.pinExpiresAt) &&
          (
            (
              resource.data.authorId == request.auth.uid &&
              request.resource.data.authorId == resource.data.authorId &&
              request.resource.data.spaceId == resource.data.spaceId &&
              request.resource.data.moderationStatus == resource.data.moderationStatus &&
              request.resource.data.pinnedAt == resource.data.pinnedAt &&
              request.resource.data.pinExpiresAt == resource.data.pinExpiresAt &&
              request.resource.data.diff(resource.data).changedKeys().hasOnly([
                'content',
                'attachments',
                'tags',
                'audience',
                'shareToCampus',
                'qualityScore',
                'toolContext',
                'engagementSummary',
                'updatedAt'
              ]) &&
              request.resource.data.diff(resource.data).addedKeys().hasOnly([]) &&
              request.resource.data.diff(resource.data).removedKeys().hasOnly([])
            ) ||
            (
            canModerate(getSpaceDoc(spaceId).data, request.auth.uid) &&
              request.resource.data.authorId == resource.data.authorId &&
              request.resource.data.spaceId == resource.data.spaceId &&
              request.resource.data.diff(resource.data).changedKeys().hasOnly([
                'moderationStatus',
                'updatedAt'
              ]) &&
              request.resource.data.diff(resource.data).addedKeys().hasOnly([]) &&
              request.resource.data.diff(resource.data).removedKeys().hasOnly([])
            ) ||
            (
            canPin(getSpaceDoc(spaceId).data, request.auth.uid) &&
              request.resource.data.authorId == resource.data.authorId &&
              request.resource.data.spaceId == resource.data.spaceId &&
              request.resource.data.diff(resource.data).changedKeys().hasOnly([
                'pinnedAt',
                'pinExpiresAt',
                'updatedAt'
              ]) &&
              request.resource.data.diff(resource.data).addedKeys().hasOnly([]) &&
              request.resource.data.diff(resource.data).removedKeys().hasOnly([])
            )
          );

        allow delete: if false;

        match /comments/{commentId} {
          allow read: if isAuthenticated() &&
            isUBUser() &&
            spaceExists(spaceId) &&
            campusMatches(getSpaceDoc(spaceId).data.campusId) &&
            postVisibleTo(getSpaceDoc(spaceId).data, get(/databases/$(database)/documents/spaces/$(spaceId)/posts/$(postId)).data, request.auth.uid);

          allow create: if isAuthenticated() &&
            isUBUser() &&
            spaceExists(spaceId) &&
            campusMatches(getSpaceDoc(spaceId).data.campusId) &&
            memberMayPost(getSpaceDoc(spaceId).data, request.auth.uid) &&
            request.resource.data.authorId == request.auth.uid;

          allow update: if isAuthenticated() &&
            resource.data.authorId == request.auth.uid;

          allow delete: if false;
        }
      }

      match /members/{memberId} {
        allow read: if isAuthenticated() &&
          isUBUser() &&
          spaceExists(spaceId) &&
          campusMatches(getSpaceDoc(spaceId).data.campusId) &&
          (
            canModerate(getSpaceDoc(spaceId).data, request.auth.uid) ||
            memberId == request.auth.uid
          );

        allow create, update: if isAuthenticated() &&
          isUBUser() &&
          spaceExists(spaceId) &&
          campusMatches(getSpaceDoc(spaceId).data.campusId) &&
          canPin(getSpaceDoc(spaceId).data, request.auth.uid) &&
          request.resource.data.profileId == memberId;

        allow delete: if isAuthenticated() &&
          isUBUser() &&
          spaceExists(spaceId) &&
          campusMatches(getSpaceDoc(spaceId).data.campusId) &&
          canPin(getSpaceDoc(spaceId).data, request.auth.uid);
      }

      match /events/{eventId} {
        allow read: if isAuthenticated() &&
          isUBUser() &&
          spaceExists(spaceId) &&
          campusMatches(getSpaceDoc(spaceId).data.campusId);

        allow write: if isAuthenticated() &&
          isUBUser() &&
          spaceExists(spaceId) &&
          campusMatches(getSpaceDoc(spaceId).data.campusId) &&
          canPin(getSpaceDoc(spaceId).data, request.auth.uid);
      }

      // Join Requests — campus-scoped, leaders/mods can list; any UB user can create their own pending request
      match /joinRequests/{requestId} {
        allow read: if isAuthenticated() &&
          isUBUser() &&
          spaceExists(spaceId) &&
          campusMatches(getSpaceDoc(spaceId).data.campusId) &&
          canModerate(getSpaceDoc(spaceId).data, request.auth.uid);

        allow create: if isAuthenticated() &&
          isUBUser() &&
          spaceExists(spaceId) &&
          campusMatches(getSpaceDoc(spaceId).data.campusId) &&
          request.resource.data.profileId == request.auth.uid &&
          (request.resource.data.status == null || request.resource.data.status == 'pending') &&
          request.resource.data.requestedAt != null;

        allow update, delete: if false;
      }
    }

    // ========================================
    // SCHOOLS COLLECTION
    // ========================================
    match /schools/{schoolId} {
      // Public read for school list
      allow read: if true;
      allow write: if isAdmin();
    }

    // ========================================
    // WAITLIST - CAMPUS SPECIFIC
    // ========================================
    match /schools/{schoolId}/waitlist/{email} {
      allow read: if isAdmin();
      allow create: if true; // Anyone can join waitlist
      allow update: if false; // Can't modify waitlist entries
      allow delete: if isAdmin();
    }

    // ========================================
    // ADMIN COLLECTIONS
    // ========================================
    match /admins/{adminId} {
      allow read, write: if isAdmin() && isUBUser();
    }

    match /builderRequests/{requestId} {
      allow read: if isAuthenticated() &&
        isUBUser() &&
        (isOwner(resource.data.userId) || isAdmin());

      allow create: if isAuthenticated() &&
        isUBUser() &&
        isOwner(request.resource.data.userId) &&
        request.resource.data.campusId == getUserCampus();

      allow update: if isAdmin() && isUBUser();
      allow delete: if false;
    }

    // ========================================
    // FEATURE FLAGS
    // ========================================
    match /featureFlags/{flagId} {
      allow read: if isAuthenticated() && isUBUser();
      allow write: if isAdmin() && isUBUser();
    }

    // ========================================
    // RITUALS - CAMPUS SPECIFIC
    // ========================================
    match /rituals/{ritualId} {
      allow read: if isAuthenticated() &&
        isUBUser() &&
        (resource.data.campusId == getUserCampus() ||
         resource.data.isGlobal == true);

      allow write: if isAdmin() &&
        isUBUser() &&
        request.resource.data.campusId == getUserCampus();

      match /participation/{userId} {
        allow read: if isAuthenticated() &&
          isUBUser() &&
          (isOwner(userId) || isAdmin());

        allow write: if isOwner(userId) &&
          isUBUser() &&
          get(/databases/$(database)/documents/rituals/$(ritualId)).data.campusId == getUserCampus();
      }
    }

    // Tools rules are defined above under "TOOLS (HiveLab)" and should not be redefined here.

    // ========================================
    // ACTIVITY & ANALYTICS
    // ========================================
    match /activityEvents/{eventId} {
      allow read: if isAuthenticated() &&
        isUBUser() &&
        resource.data.campusId == getUserCampus();

      allow create: if isAuthenticated() &&
        isUBUser() &&
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.campusId == getUserCampus();

      allow update, delete: if false;
    }

    // ========================================
    // NOTIFICATIONS
    // ========================================
    match /notifications/{userId}/userNotifications/{notificationId} {
      allow read: if isOwner(userId) && isUBUser();
      allow write: if isOwner(userId) && isUBUser();
    }

    // ========================================
    // PRESENCE & REALTIME
    // ========================================
    match /presence/{userId} {
      allow read: if isAuthenticated() && isUBUser();
      allow write: if isOwner(userId) &&
        isUBUser() &&
        request.resource.data.campusId == getUserCampus();
    }

    // ========================================
    // DENY ALL OTHER ACCESS
    // ========================================
    // This is the default deny rule - if no rule matches above, deny access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

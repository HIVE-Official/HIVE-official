rules_version = '2';

// HIVE UI Platform - Comprehensive Firestore Security Rules
// This ruleset is designed to secure all Firestore collections while enabling
// proper functionality across the HIVE platform.

service cloud.firestore {
  match /databases/{database}/documents {
    // ======== HELPER FUNCTIONS ========
    
    // Authentication helpers
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Role-based access checks
    function getUserRole() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
    }
    
    function hasRole(minimumRole) {
      let roleValue = {
        'public': 0,
        'verified': 1,
        'verifiedPlus': 2,
        'moderator': 3,
        'admin': 4
      };
      let userRole = getUserRole();
      return roleValue[userRole] >= roleValue[minimumRole];
    }
    
    function isAdmin() {
      return hasRole('admin');
    }
    
    function isModerator() {
      return hasRole('moderator');
    }
    
    function isVerifiedPlus() {
      return hasRole('verifiedPlus');
    }
    
    function isVerified() {
      return hasRole('verified');
    }
    
    // Space/Club related helpers (optimized for performance)
    function isSpaceAdmin(spaceId) {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/space_admin_index/$(request.auth.uid + "_" + spaceId));
    }
    
    function isSpaceModerator(spaceId) {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/space_moderator_index/$(request.auth.uid + "_" + spaceId));
    }
    
    function isSpaceMember(spaceId) {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/space_member_index/$(request.auth.uid + "_" + spaceId));
    }
    
    function isSpaceLeader(spaceId) {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/space_leader_index/$(request.auth.uid + "_" + spaceId));
    }
    
    function isClubMember(clubId) {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/club_member_index/$(request.auth.uid + "_" + clubId));
    }
    
    function isClubLeader(clubId) {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/club_leader_index/$(request.auth.uid + "_" + clubId));
    }
    
    // Content privacy helpers
    function isSpacePublic(spaceId) {
      return exists(/databases/$(database)/documents/space_privacy/$(spaceId)) &&
             get(/databases/$(database)/documents/space_privacy/$(spaceId)).data.isPublic == true;
    }
    
    function isEventPublic(eventId) {
      return exists(/databases/$(database)/documents/event_privacy/$(eventId)) &&
             get(/databases/$(database)/documents/event_privacy/$(eventId)).data.isPublic == true;
    }
    
    function isClubPublic(clubId) {
      return !exists(/databases/$(database)/documents/club_privacy/$(clubId)) ||
             get(/databases/$(database)/documents/club_privacy/$(clubId)).data.isPublic == true;
    }
    
    // Relationship helpers
    function areFriends(userId) {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/friend_index/$(request.auth.uid + "_" + userId));
    }
    
    function isChatParticipant(chatId) {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/chats/$(chatId)) &&
             request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds;
    }
    
    // New helper functions for sub-collection based membership checks
    function isMember(spaceId, userId) {
      return isAuthenticated() && exists(/databases/$(database)/documents/spaces/$(spaceId)/members/$(userId));
    }

    function isBuilder(spaceId, userId) {
      // Ensure the user is a member before trying to get their role.
      return isMember(spaceId, userId) &&
             get(/databases/$(database)/documents/spaces/$(spaceId)/members/$(userId)).data.role == 'builder';
    }
    
    // Rate limiting helper functions
    function isRateLimited(collectionName) {
      let userId = request.auth.uid;
      let limitPath = /databases/$(database)/documents/rate_limits/$(userId);
      let now = request.time;
      let threshold = Duration.value(1, 'h');
      
      return exists(limitPath) &&
             get(limitPath).data[collectionName + '_last_write'] > now - threshold &&
             get(limitPath).data[collectionName + '_count'] >= 10;
    }
    
    // Event state and temporal validation
    function getEventState(eventId) {
      let event = get(/databases/$(database)/documents/events/$(eventId)).data;
      let now = request.time.toMillis();
      let startTime = event.startDate.toMillis();
      let endTime = event.endDate != null ? event.endDate.toMillis() : startTime + Duration.value(2, 'h').seconds() * 1000;
      let postEventWindow = 12 * 60 * 60 * 1000; // 12 hours in milliseconds
      
      // Determine state based on times
      if (event.published != true) {
        return 'draft';
      } else if (now < startTime) {
        return 'published';
      } else if (now >= startTime && now <= endTime) {
        return 'live';
      } else if (now > endTime && now <= endTime + postEventWindow) {
        return 'completed';
      } else {
        return 'archived';
      }
    }
    
    function canEditEventDetails(eventId) {
      let event = get(/databases/$(database)/documents/events/$(eventId)).data;
      let eventState = getEventState(eventId);
      let isCreator = request.auth.uid == event.createdBy;
      
      return (eventState == 'draft') || 
             (eventState == 'published' && isCreator) ||
             (eventState == 'live' && isAdmin());
    }
    
    function isEditingCoreEventDetails() {
      return request.resource.data.diff(resource.data).affectedKeys()
        .hasAny(['startDate', 'endDate', 'location', 'title']);
    }
    
    // Validation helper functions
    function isValidEventData(data) {
      return data.title is string && 
             data.title.size() > 0 &&
             data.title.size() <= 100 &&
             data.createdBy is string && 
             data.createdBy == request.auth.uid &&
             data.startDate is timestamp && 
             data.startDate > request.time;
    }
    
    function isValidSpaceData(data) {
      return data.name is string &&
             data.name.size() > 2 && data.name.size() <= 50 &&
             data.description is string &&
             data.description.size() > 9 && data.description.size() <= 500 &&
             data.imageUrl is string && data.imageUrl.matches('^https?://.*') &&
             data.category in ['Major', 'Residential', 'Student Life', 'Club', 'General'] &&
             data.createdBy == request.auth.uid &&
             data.isPublic is bool;
    }
    
    function isValidClubData(data) {
      return data.name is string && 
             data.name.size() > 0 &&
             data.name.size() <= 100 &&
             data.description is string;
    }
    
    function isValidChatMessageData(data) {
      return data.text is string &&
             data.senderId is string &&
             data.senderId == request.auth.uid &&
             data.timestamp is timestamp;
    }
    
    // Post validation functions
    function isValidPostData(data, spaceId) {
      return data.authorId is string &&
             data.authorId == request.auth.uid &&
             data.spaceId is string &&
             data.spaceId == spaceId &&
             data.content is string &&
             data.content.size() >= 1 &&
             data.content.size() <= 2000 &&
             data.type is string &&
             data.type in ['text', 'image', 'poll', 'event', 'tool_share'] &&
             data.visibility is string &&
             data.visibility in ['public', 'members_only'] &&
             data.status is string &&
             data.status == 'active' &&
             data.threadDepth is number &&
             data.threadDepth >= 0 &&
             data.threadDepth <= 3 && // Limit thread depth
             isValidPostAuthor(data.author) &&
             isValidPostMetrics(data.metrics);
    }
    
    function isValidPostAuthor(author) {
      return author.name is string &&
             author.name.size() > 0 &&
             author.handle is string &&
             author.handle.size() > 0 &&
             author.role is string &&
             author.role in ['member', 'builder'];
    }
    
    function isValidPostMetrics(metrics) {
      return metrics.replyCount is number &&
             metrics.replyCount >= 0 &&
             metrics.likeCount is number &&
             metrics.likeCount >= 0 &&
             metrics.shareCount is number &&
             metrics.shareCount >= 0 &&
             metrics.viewCount is number &&
             metrics.viewCount >= 0;
    }
    
    function isValidPostUpdate(newData, oldData) {
      // Only allow updating content, visibility, and metrics
      let allowedFields = ['content', 'visibility', 'updatedAt', 'metrics'];
      return newData.diff(oldData).affectedKeys().hasOnly(allowedFields) &&
             // Content validation if being updated
             (!newData.diff(oldData).affectedKeys().hasAny(['content']) ||
              (newData.content is string && 
               newData.content.size() >= 1 && 
               newData.content.size() <= 2000)) &&
             // Visibility validation if being updated
             (!newData.diff(oldData).affectedKeys().hasAny(['visibility']) ||
              newData.visibility in ['public', 'members_only']);
    }
    
    function isValidModerationUpdate(newData, oldData) {
      // Builders can only update status and moderation fields
      let allowedFields = ['status', 'moderatedBy', 'moderatedAt', 'moderationReason', 'updatedAt'];
      return newData.diff(oldData).affectedKeys().hasOnly(allowedFields) &&
             newData.status in ['active', 'hidden', 'flagged'] &&
             newData.moderatedBy == request.auth.uid;
    }
    
    // ======== COLLECTION GROUP QUERIES ========
    
    // Enable collection group queries for spaces (important for discovery/onboarding)
    match /{path=**}/spaces/{spaceId} {
      allow read: if isAuthenticated();
    }
    
    // Enable collection group queries for events (main feed functionality)
    match /{path=**}/events/{eventId} {
      allow read: if isAuthenticated();
    }
    
    // Enable collection group queries for posts
    match /{path=**}/posts/{postId} {
      allow read: if isAuthenticated() && 
                  (!resource.data.isHidden || 
                   resource.data.authorId == request.auth.uid || 
                   isModerator() || 
                   isAdmin());
    }
    
    // ======== USER MANAGEMENT ========
    
    // Handles are stored in a separate collection to enforce uniqueness.
    // The user's handle is the document ID.
    match /handles/{handle} {
      // Allow anyone to check for existence
      allow get: if request.auth != null;
      // Only allow creation if the user is authenticated and setting their own handle
      allow create: if request.auth.uid != null;
    }

    // Users can only read and write their own data.
    match /users/{userId} {
      // Users can read their own document
      allow read: if request.auth.uid == userId;
      // Allow public read of non-sensitive fields if profile is public
      allow get: if resource.data.isPublic == true;
      
      // User creation is only allowed through backend functions with proper validation
      allow create: if false;
      
      // User updates must preserve critical immutable fields
      allow update: if request.auth.uid == userId &&
                   // schoolId cannot be changed once set
                   (resource.data.schoolId == request.resource.data.schoolId) &&
                   // handle cannot be changed once set
                   (resource.data.handle == request.resource.data.handle) &&
                   // uid cannot be changed
                   (resource.data.uid == request.resource.data.uid);

      // Secure the motion sub-collection
      match /motion/{motionId} {
        allow read, write: if request.auth.uid == userId;
      }
      
      // Secure the personalTools sub-collection
      match /personalTools/{toolId} {
        allow read, write: if request.auth.uid == userId;
      }

      // Secure the follows and mutes sub-collections
      match /(follows|mutes)/{docId} {
        allow read, write: if request.auth.uid == userId;
      }

      // User notifications subcollection
      match /notifications/{notificationId} {
        allow read, update, delete: if isOwner(userId);
        allow create: if isAdmin() || isOwner(userId);
      }
      
      // User preferences subcollection
      match /preferences/{preferenceId} {
        allow read, write: if isOwner(userId);
      }
      
      // User analytics subcollection (read-only for users)
      match /analytics/{analyticsId} {
        allow read: if isOwner(userId);
        allow write: if isAdmin();
      }
    }
    
    // User profiles
    match /user_profiles/{userId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isOwner(userId);
      allow update: if isAuthenticated() && (isOwner(userId) || isAdmin());
      allow delete: if isAdmin();
    }
    
    // Public user index - for discoverability
    match /public_user_index/{userId} {
      allow read: if true; // Public profile index is readable by anyone
      allow write: if isOwner(userId) || isAdmin();
    }
    
    // User sessions
    match /user_sessions/{userId} {
      allow read, write: if isOwner(userId);
    }
    
    // User rate limits
    match /rate_limits/{userId} {
      allow read: if isOwner(userId);
      allow create, update: if isAdmin() || (isOwner(userId) && !isRateLimited('rate_limits'));
      allow delete: if isAdmin();
    }
    
    // User authentication records
    match /auth_records/{userId} {
      allow read: if isOwner(userId);
      allow write: if isAdmin();
    }
    
    // User settings
    match /user_settings/{userId} {
      allow read: if isOwner(userId);
      allow write: if isOwner(userId);
    }
    
    // ======== SPACES/CLUBS MANAGEMENT ========
    
    // Spaces collection
    match /spaces/{spaceId} {
      // Public data is readable by any authenticated user for discovery.
      allow get, list: if isAuthenticated();

      // Space creation and deletion are admin/backend-only tasks.
      allow create, delete: if false;

      // Only a builder of the space can update it.
      // They can only update specific, non-critical fields.
      allow update: if isBuilder(spaceId, request.auth.uid) &&
                      request.resource.data.diff(resource.data).affectedKeys()
                        .hasOnly(['description', 'bannerUrl', 'status', 'updatedAt']);

      // === Members Sub-collection ===
      match /members/{userId} {
        // Members can see who else is in the space. A user can check their own membership.
        allow get, list: if isMember(spaceId, request.auth.uid);

        // All membership changes (join, leave, role change) must go through a
        // secure Cloud Function to ensure data integrity (e.g., memberCount updates).
        allow create, update, delete: if false;
      }
      
      // Space events subcollection
      match /events/{eventId} {
        allow read: if isAuthenticated() && (
                    isEventPublic(eventId) || 
                    isSpaceMember(spaceId) || 
                    isAdmin());
        
        allow create: if isAuthenticated() && 
                     isVerified() && 
                     isSpaceMember(spaceId) && 
                     isValidEventData(request.resource.data);
        
        allow update: if isAuthenticated() && (
                      (request.auth.uid == resource.data.createdBy && 
                      canEditEventDetails(eventId) && 
                      (!isEditingCoreEventDetails() || getEventState(eventId) == 'draft')) ||
                      isAdmin()
                     );
        
        allow delete: if isAuthenticated() && (
                      (request.auth.uid == resource.data.createdBy && 
                      getEventState(eventId) == 'draft') || 
                      isAdmin()
                     );
        
        // Event RSVPs subcollection
        match /rsvps/{userId} {
          allow read: if isAuthenticated();
          allow create, update: if isAuthenticated() && 
                                isOwner(userId) && 
                                getEventState(eventId) != 'archived';
          allow delete: if isAuthenticated() && 
                       (isOwner(userId) || isAdmin());
        }
        
        // Event comments subcollection
        match /comments/{commentId} {
          allow read: if isAuthenticated();
          allow create: if isAuthenticated() && 
                       request.resource.data.authorId == request.auth.uid &&
                       getEventState(eventId) != 'archived';
          allow update, delete: if isAuthenticated() && 
                               (resource.data.authorId == request.auth.uid || 
                                isAdmin() || 
                                isSpaceModerator(spaceId));
        }
      }
      
      // Space posts subcollection
      match /posts/{postId} {
        // Allow reads for any member of the space.
        allow get, list: if isMember(spaceId, request.auth.uid);

        // Allow creation for any member of the space with comprehensive validation.
        allow create: if isMember(spaceId, request.auth.uid) &&
                         isValidPostData(request.resource.data, spaceId);

        // Allow updates only by the original author with field restrictions.
        allow update: if isOwner(resource.data.authorId) &&
                         isValidPostUpdate(request.resource.data, resource.data);

        // Allow deletion by the original author or a space builder.
        allow delete: if isOwner(resource.data.authorId) || 
                         isBuilder(spaceId, request.auth.uid);
        
        // Moderation: Allow builders to update post status for moderation
        allow update: if isBuilder(spaceId, request.auth.uid) &&
                         isValidModerationUpdate(request.resource.data, resource.data);

        // Post comments subcollection
        match /comments/{commentId} {
          allow read: if isAuthenticated() && (
                      isSpaceMember(spaceId) || 
                      isSpacePublic(spaceId));
          
          allow create: if isAuthenticated() && 
                       isSpaceMember(spaceId) && 
                       request.resource.data.authorId == request.auth.uid;
          
          allow update, delete: if isAuthenticated() && (
                               resource.data.authorId == request.auth.uid || 
                               isSpaceAdmin(spaceId) || 
                               isAdmin());
        }
      }

      // Space analytics subcollection
      match /analytics/{analyticsId} {
        allow read: if isSpaceMember(spaceId) || isAdmin();
        allow write: if isAdmin();
      }
      
      // Space tools subcollection
      match /tools/{toolId} {
        allow read: if isSpaceMember(spaceId);
        allow create: if isSpaceMember(spaceId) && isVerified();
        allow update, delete: if isBuilder(spaceId, request.auth.uid) || 
                              resource.data.createdBy == request.auth.uid ||
                              isAdmin();
      }
      
      // Space moderation subcollection
      match /moderation/{moderationId} {
        allow read: if isBuilder(spaceId, request.auth.uid) || isAdmin();
        allow write: if isBuilder(spaceId, request.auth.uid) || isAdmin();
      }
    }
    
    // ======== CLUBS MANAGEMENT ========
    
    // Clubs collection
    match /clubs/{clubId} {
      allow read: if isAuthenticated() && (
                  isClubPublic(clubId) || 
                  isClubMember(clubId) || 
                  isAdmin());
      
      allow create: if isAuthenticated() && 
                    isVerified() && 
                    isValidClubData(request.resource.data) && 
                    request.resource.data.createdBy == request.auth.uid;
      
      allow update: if isAuthenticated() && (
                   isClubLeader(clubId) || 
                   isAdmin());
      
      allow delete: if isAuthenticated() && isAdmin();
      
      // Club members subcollection
      match /members/{memberId} {
        allow read: if isAuthenticated() && (
                    isClubMember(clubId) || 
                    isClubLeader(clubId) || 
                    isAdmin());
        
        allow create: if isAuthenticated() && (
                     (request.resource.data.userId == request.auth.uid && isClubPublic(clubId)) || 
                     isClubLeader(clubId) || 
                     isAdmin());
        
        allow update: if isAuthenticated() && (
                     isClubLeader(clubId) || 
                     isAdmin());
        
        allow delete: if isAuthenticated() && (
                     (resource.data.userId == request.auth.uid) || 
                     isClubLeader(clubId) || 
                     isAdmin());
      }
    }
    
    // ======== CHAT MANAGEMENT ========
    
    // Chats collection
    match /chats/{chatId} {
      allow read: if isAuthenticated() && isChatParticipant(chatId);
      
      allow create: if isAuthenticated() && 
                   request.resource.data.participantIds is list && 
                   request.auth.uid in request.resource.data.participantIds;
      
      allow update: if isAuthenticated() && 
                   isChatParticipant(chatId);
      
      allow delete: if isAuthenticated() && (
                   isChatParticipant(chatId) || 
                   isAdmin());
      
      // Chat messages subcollection
      match /messages/{messageId} {
        allow read: if isAuthenticated() && 
                   isChatParticipant(chatId);
        
        allow create: if isAuthenticated() && 
                     isChatParticipant(chatId) && 
                     isValidChatMessageData(request.resource.data);
        
        allow update: if isAuthenticated() && 
                     request.auth.uid == resource.data.senderId;
        
        allow delete: if isAuthenticated() && (
                     request.auth.uid == resource.data.senderId || 
                     isAdmin());
      }
    }
    
    // ======== EVENTS MANAGEMENT ========
    
    // Events collection (top level)
    match /events/{eventId} {
      allow read: if isAuthenticated();
      
      allow create: if isAuthenticated() && 
                   isVerified() && 
                   isValidEventData(request.resource.data);
      
      allow update: if isAuthenticated() && (
                   (request.auth.uid == resource.data.createdBy && 
                   canEditEventDetails(eventId)) || 
                   isAdmin());
      
      allow delete: if isAuthenticated() && (
                   (request.auth.uid == resource.data.createdBy && 
                   getEventState(eventId) == 'draft') || 
                   isAdmin());
    }
    
    // ======== SYSTEM COLLECTIONS ========
    
    // System settings (admin only)
    match /system_settings/{settingId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }
    
    // Moderation actions
    match /moderation_actions/{actionId} {
      allow read: if isAuthenticated() && 
                 (resource.data.targetUserId == request.auth.uid || 
                  isModerator() || 
                  isAdmin());
      
      allow create, update: if isAuthenticated() && 
                          (isModerator() || isAdmin());
      
      allow delete: if isAdmin();
    }
    
    // Feature flags
    match /feature_flags/{flagId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }
    
    // App configurations
    match /app_config/{configId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    // Allow public read access to version information
    match /version/{docId} {
      allow read: if true;
    }

    // Secure the feed collection and like sub-collections
    match /feed/{cardId} {
      allow read: if request.auth != null;

      match /likes/{userId} {
        allow read, write: if request.auth.uid == userId;
      }
    }

    // Allow read access to posts for authenticated users
    match /posts/{postId} {
      allow read: if request.auth != null;
    }

    // ======== SCHOOLS ========

    // The 'schools' collection is public-readable for the welcome screen,
    // but should only be writable by admins.
    match /schools/{schoolId} {
      // Anyone can see the list of schools.
      allow read: if true;
      
      // Only admins can create, update, or delete school documents.
      allow write: if isAdmin();
      
      match /waitlist_entries/{entryId} {
        // No one can read the waitlist entries directly from the client.
        // This data should be considered private.
        allow read: if false;
        
        // No one can write directly to the waitlist. 
        // All waitlist joins must go through the `joinWaitlist` Cloud Function,
        // which uses the Admin SDK and bypasses these rules.
        allow write: if false;
      }

      // School feed subcollection
      match /feed/{feedId} {
        allow read: if isAuthenticated();
        allow write: if isAdmin();
      }
      
      // School trending subcollection
      match /trending/{trendingId} {
        allow read: if isAuthenticated();
        allow write: if isAdmin();
      }
      
      // School metrics subcollection
      match /metrics/{metricId} {
        allow read: if isAdmin();
        allow write: if isAdmin();
      }
    }

    // ======== SPACES & MEMBERS ========

    // Rules for the 'spaces' collection and its 'members' sub-collection.
    match /spaces/{spaceId} {
      // Allow any authenticated user to read space data for discovery.
      allow get, list: if isAuthenticated();

      // Creating and deleting spaces is an admin-only action, done via backend.
      allow create, delete: if false;

      // Allow users with the 'builder' role to update specific fields.
      // They can only update the description and banner. Other fields are immutable.
      allow update: if isBuilder(spaceId, request.auth.uid) &&
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['description', 'bannerUrl']);

      // Rules for the 'members' sub-collection within each space.
      match /members/{userId} {
        // Any authenticated user can see who is a member of a space.
        allow get, list: if isAuthenticated();

        // Joining a space is handled by backend functions (auto-join).
        // Users cannot join a space directly.
        allow create: if false;

        // A user can leave a space by deleting their own member document.
        allow delete: if isOwner(userId);

        // A user can update their own membership to request a builder role.
        // They can only change their role from 'member' to 'requested_builder'.
        allow update: if isOwner(userId) &&
                        request.resource.data.role == 'requested_builder' &&
                        resource.data.role == 'member';
      }
      
      // Rules for the 'posts' sub-collection within each space.
      match /posts/{postId} {
        // Allow reads for any member of the space.
        allow get, list: if isMember(spaceId, request.auth.uid);

        // Allow creation for any member of the space with comprehensive validation.
        allow create: if isMember(spaceId, request.auth.uid) &&
                         isValidPostData(request.resource.data, spaceId);

        // Allow updates only by the original author with field restrictions.
        allow update: if isOwner(resource.data.authorId) &&
                         isValidPostUpdate(request.resource.data, resource.data);

        // Allow deletion by the original author or a space builder.
        allow delete: if isOwner(resource.data.authorId) || 
                         isBuilder(spaceId, request.auth.uid);
        
        // Moderation: Allow builders to update post status for moderation
        allow update: if isBuilder(spaceId, request.auth.uid) &&
                         isValidModerationUpdate(request.resource.data, resource.data);

        // Post comments subcollection
        match /comments/{commentId} {
          allow read: if isAuthenticated() && (
                      isSpaceMember(spaceId) || 
                      isSpacePublic(spaceId));
          
          allow create: if isAuthenticated() && 
                       isSpaceMember(spaceId) && 
                       request.resource.data.authorId == request.auth.uid;
          
          allow update, delete: if isAuthenticated() && (
                               resource.data.authorId == request.auth.uid || 
                               isSpaceAdmin(spaceId) || 
                               isAdmin());
        }
      }
    }

    // Rules for the Creation Engine
    match /elements/{elementId} {
      allow read: if request.auth != null;
      allow write: if request.auth.token.admin == true;
    }

    match /tools/{toolId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      allow update, delete: if request.auth.uid == resource.data.ownerId || request.auth.uid in resource.data.collaborators;
    }

    // ======== COMPREHENSIVE STRUCTURE ADDITIONS ========
    
    // Moderation collections
    match /content_reports/{reportId} {
      allow read: if resource.data.reportedBy == request.auth.uid || 
                 isModerator() || isAdmin();
      allow create: if isAuthenticated() && 
                   request.resource.data.reportedBy == request.auth.uid;
      allow update: if isModerator() || isAdmin();
      allow delete: if isAdmin();
    }
    
    match /moderation_queue/{queueId} {
      allow read, write: if isModerator() || isAdmin();
    }
    
    match /moderation_settings/{settingId} {
      allow read: if isModerator() || isAdmin();
      allow write: if isAdmin();
    }
    
    match /safety_reports/{reportId} {
      allow read: if resource.data.reportedBy == request.auth.uid || 
                 isModerator() || isAdmin();
      allow create: if isAuthenticated() && 
                   request.resource.data.reportedBy == request.auth.uid;
      allow update, delete: if isAdmin();
    }

    // Creation engine collections
    match /creation_tools/{toolId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isVerified() &&
                   request.resource.data.createdBy == request.auth.uid;
      allow update, delete: if resource.data.createdBy == request.auth.uid || isAdmin();
    }

    match /creation_templates/{templateId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isVerified() &&
                   request.resource.data.createdBy == request.auth.uid;
      allow update, delete: if resource.data.createdBy == request.auth.uid || isAdmin();
    }

    // Analytics collections
    match /platform_analytics/{analyticsId} {
      allow read: if isAdmin();
      allow write: if isAdmin();
    }
    
    match /user_behavior/{behaviorId} {
      allow read: if resource.data.userId == request.auth.uid || isAdmin();
      allow write: if isAdmin();
    }
    
    match /content_metrics/{metricId} {
      allow read: if isAdmin();
      allow write: if isAdmin();
    }
  }
} 
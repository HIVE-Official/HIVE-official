---
description: 
globs: 
alwaysApply: true
---
# HIVE UI React/TypeScript Syntax and Linting Rules

## 1. Syntax Completion

### 1.1 Bracket and Parenthesis Completion
- Always ensure matching closing brackets and parentheses
- Recommended keyboard shortcut: Ctrl+Shift+\ (VS Code) to jump to matching bracket
- Configure editor to automatically highlight matching brackets
- Use code formatting before commits (Shift+Alt+F in VS Code)

### 1.2 JSX/TSX Component Construction
- When using complex JSX structures, format your code with proper indentation
- For components with many props, place each prop on a new line
- Always add a trailing comma after the last prop to help with formatting:
  ```tsx
  const MyComponent = () => {
    return (
      <Container
        width="100%"
        height={200}
        className="bg-blue-500"
        aria-label="Hello World"
      >
        <Text>Hello World</Text>
      </Container>
    );
  };
  ```

## 2. Required Parameters

### 2.1 Component Props
- Always provide all required props for components
- Use TypeScript interfaces to define component props clearly
- Common React patterns with required props:
  - Custom hooks must return consistent types
  - Event handlers should be properly typed
  - Children props should use `React.ReactNode`

### 2.2 Prop Naming
- Use camelCase for prop names (React convention)
- Be precise with prop types, use TypeScript interfaces
- Common naming patterns:
  - `onClick` vs `onPress` vs `onSelect`
  - `children` vs `content`
  - `className` vs `style`
  - `disabled` vs `isDisabled`

## 3. TypeScript Typing

### 3.1 Type Safety
- Always use explicit types for function parameters and return values
- Use `const` assertions where appropriate
- Avoid `any` type - use proper TypeScript types

### 3.2 Valid Type Patterns
- Use interface for object shapes, type for unions
- Prefer type inference where TypeScript can determine types
- Use generic types for reusable components:
  ```tsx
  interface ButtonProps<T = HTMLButtonElement> {
    onClick: (event: React.MouseEvent<T>) => void;
    children: React.ReactNode;
    disabled?: boolean;
  }
  ```

## 4. Import Management

### 4.1 Managing Imports
- Remove unused imports (VS Code shortcut: Alt+Shift+O)
- Use absolute imports with path aliases (@/, @hive/*)
- Group imports: external libraries, internal modules, relative imports

### 4.2 Import Best Practices
- Use type-only imports when importing only for types:
  ```tsx
  import type { User } from '@/types/user';
  import { getUserData } from '@/api/users';
  ```
- Avoid circular dependencies
- Use dynamic imports for code splitting when appropriate

## 5. Unused Code

### 5.1 Cleaning Unused Code
- Remove unused variables, functions, and components
- Use ESLint rules to catch unused imports and variables
- Clean up console.logs before committing

### 5.2 Dead Code Prevention
- Run `pnpm lint` regularly to identify unused elements
- Use TypeScript strict mode to catch potential issues
- Review codebase periodically to remove accumulated dead code

## 6. Async Operations & Hooks

### 6.1 useEffect Safety
- Always clean up subscriptions and async operations
- Use AbortController for fetch requests
- Handle component unmounting properly:
  ```tsx
  useEffect(() => {
    let isMounted = true;
    
    const fetchData = async () => {
      try {
        const data = await api.getData();
        if (isMounted) {
          setData(data);
        }
      } catch (error) {
        if (isMounted) {
          setError(error);
        }
      }
    };
    
    fetchData();
    
    return () => {
      isMounted = false;
    };
  }, []);
  ```

### 6.2 Custom Hooks Patterns
- Always return consistent types from custom hooks
- Use proper dependency arrays in useEffect
- Handle loading and error states explicitly

## 7. Common React/Next.js Patterns

### 7.1 Component Structure
- Use React Server Components by default
- Only use "use client" when necessary (hooks, event handlers, browser APIs)
- Properly handle loading and error states:
  ```tsx
  import { Suspense } from 'react';
  import { ErrorBoundary } from '@/components/ErrorBoundary';
  
  export default function Page() {
    return (
      <ErrorBoundary>
        <Suspense fallback={<Loading />}>
          <AsyncComponent />
        </Suspense>
      </ErrorBoundary>
    );
  }
  ```

### 7.2 State Management
- Use useState for local component state
- Use Zustand for global state when needed
- Use React Query for server state management

## 8. Testing and Verification

### 8.1 Pre-Commit Checks
- Run `pnpm lint` before committing code
- Run `pnpm typecheck` to verify TypeScript types
- Use Prettier for consistent formatting

### 8.2 Code Review Focus
- Pay special attention to:
  - TypeScript type safety
  - Proper prop typing
  - useEffect dependency arrays
  - Accessibility (aria-labels, semantic HTML)
  - Performance (unnecessary re-renders)

## 9. HIVE-Specific Standards

### 9.1 Styling
- Use Tailwind CSS classes exclusively
- Follow the design system in packages/tokens
- Use shadcn/ui components as base components

### 9.2 Architecture
- Follow the monorepo structure (apps/*, packages/*)
- Use path aliases consistently
- Keep components small and focused
- Separate business logic from UI components
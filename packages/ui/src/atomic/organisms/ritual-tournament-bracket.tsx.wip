'use client';

import * as React from 'react';
import { cn } from '../../lib/utils';
import { Card } from '../atoms/card';
import { Button } from '../atoms/button';
import { VoteBar } from '../atoms/percent-bar';
import { Trophy, Users, Clock, Check } from 'lucide-react';
import type { TournamentConfig } from '@hive/core';

export interface TournamentMatchup {
  id: string;
  round: number;
  position: number;
  contestant1: {
    id: string;
    name: string;
    description?: string;
    votes: number;
    imageUrl?: string;
  };
  contestant2: {
    id: string;
    name: string;
    description?: string;
    votes: number;
    imageUrl?: string;
  };
  winner?: string;
  isActive: boolean;
  endsAt: string;
}

export interface RitualTournamentBracketProps {
  config: TournamentConfig;
  matchups: TournamentMatchup[];
  currentUserVotes?: string[]; // Array of matchup IDs user has voted in
  onVote?: (matchupId: string, contestantId: string) => Promise<void>;
  className?: string;
}

/**
 * Tournament Bracket Renderer
 *
 * Displays tournament matchups in bracket format with voting
 * Supports single-elimination, double-elimination, round-robin formats
 */
export const RitualTournamentBracket: React.FC<RitualTournamentBracketProps> = ({
  config,
  matchups,
  currentUserVotes = [],
  onVote,
  className,
}) => {
  const [votingMatchup, setVotingMatchup] = React.useState<string | null>(null);

  // Group matchups by round
  const matchupsByRound = React.useMemo(() => {
    const grouped = new Map<number, TournamentMatchup[]>();
    matchups.forEach(matchup => {
      if (!grouped.has(matchup.round)) {
        grouped.set(matchup.round, []);
      }
      grouped.get(matchup.round)!.push(matchup);
    });
    return grouped;
  }, [matchups]);

  const rounds = Array.from(matchupsByRound.keys()).sort((a, b) => a - b);
  const roundNames = React.useMemo(() => {
    const total = rounds.length;
    if (total === 0) return [];

    const names: string[] = [];
    for (let i = 0; i < total; i++) {
      if (i === total - 1) names.push('Finals');
      else if (i === total - 2) names.push('Semifinals');
      else if (i === total - 3) names.push('Quarterfinals');
      else names.push(`Round ${i + 1}`);
    }
    return names;
  }, [rounds]);

  const handleVote = async (matchupId: string, contestantId: string) => {
    if (!onVote || votingMatchup) return;

    setVotingMatchup(matchupId);
    try {
      await onVote(matchupId, contestantId);
    } finally {
      setVotingMatchup(null);
    }
  };

  const hasVotedInMatchup = (matchupId: string) => currentUserVotes.includes(matchupId);

  return (
    <div className={cn('space-y-8', className)}>
      {/* Tournament Header */}
      <Card className="border-white/10 bg-gradient-to-br from-[var(--hive-background-secondary)] to-black p-6">
        <div className="flex items-start justify-between">
          <div className="space-y-2">
            <div className="flex items-center gap-2">
              <Trophy className="h-5 w-5 text-[var(--hive-brand-primary)]" />
              <span className="text-xs font-semibold uppercase tracking-[0.2em] text-white/60">
                {config.format === 'single_elimination' ? 'Single Elimination' :
                 config.format === 'double_elimination' ? 'Double Elimination' :
                 'Round Robin'}
              </span>
            </div>
            <h2 className="text-2xl font-bold text-white">Tournament Bracket</h2>
            <div className="flex flex-wrap gap-4 text-sm text-white/60">
              <span className="flex items-center gap-1.5">
                <Users className="h-4 w-4" />
                {Object.keys(config.participants || {}).length} contestants
              </span>
              <span className="flex items-center gap-1.5">
                <Trophy className="h-4 w-4" />
                Round {config.currentRound || 1} of {rounds.length}
              </span>
            </div>
          </div>
        </div>
      </Card>

      {/* Bracket Grid */}
      <div className="space-y-8">
        {rounds.map((round, roundIndex) => {
          const roundMatchups = matchupsByRound.get(round) || [];

          return (
            <div key={round} className="space-y-4">
              {/* Round Header */}
              <div className="flex items-center gap-3">
                <div className="h-px flex-1 bg-white/10" />
                <h3 className="text-sm font-semibold uppercase tracking-[0.2em] text-white/60">
                  {roundNames[roundIndex]}
                </h3>
                <div className="h-px flex-1 bg-white/10" />
              </div>

              {/* Matchups */}
              <div className="grid gap-4 md:grid-cols-2">
                {roundMatchups.map(matchup => (
                  <MatchupCard
                    key={matchup.id}
                    matchup={matchup}
                    hasVoted={hasVotedInMatchup(matchup.id)}
                    isVoting={votingMatchup === matchup.id}
                    onVote={handleVote}
                  />
                ))}
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
};

interface MatchupCardProps {
  matchup: TournamentMatchup;
  hasVoted: boolean;
  isVoting: boolean;
  onVote: (matchupId: string, contestantId: string) => void;
}

const MatchupCard: React.FC<MatchupCardProps> = ({ matchup, hasVoted, isVoting, onVote }) => {
  const totalVotes = matchup.contestant1.votes + matchup.contestant2.votes;
  const c1Percentage = totalVotes > 0 ? (matchup.contestant1.votes / totalVotes) * 100 : 50;
  const c2Percentage = totalVotes > 0 ? (matchup.contestant2.votes / totalVotes) * 100 : 50;

  const timeRemaining = React.useMemo(() => {
    if (!matchup.isActive) return null;
    const now = Date.now();
    const ends = new Date(matchup.endsAt).getTime();
    const diff = ends - now;
    if (diff <= 0) return 'Ended';
    const hours = Math.floor(diff / (1000 * 60 * 60));
    const minutes = Math.floor((diff / (1000 * 60)) % 60);
    if (hours > 0) return `${hours}h ${minutes}m left`;
    return `${minutes}m left`;
  }, [matchup.endsAt, matchup.isActive]);

  return (
    <Card className="overflow-hidden border-white/10 bg-[var(--hive-background-secondary)] p-0">
      {/* Matchup Header */}
      {timeRemaining && matchup.isActive && (
        <div className="flex items-center justify-between border-b border-white/10 bg-white/5 px-4 py-2">
          <span className="text-xs font-medium uppercase tracking-[0.16em] text-white/60">
            Active
          </span>
          <span className="flex items-center gap-1.5 text-xs text-white/60">
            <Clock className="h-3.5 w-3.5" />
            {timeRemaining}
          </span>
        </div>
      )}

      <div className="p-4 space-y-3">
        {/* Contestant 1 */}
        <ContestantRow
          contestant={matchup.contestant1}
          isWinner={matchup.winner === matchup.contestant1.id}
          percentage={c1Percentage}
          canVote={matchup.isActive && !hasVoted && !isVoting}
          isVoting={isVoting}
          onVote={() => onVote(matchup.id, matchup.contestant1.id)}
        />

        {/* VS Divider */}
        <div className="flex items-center gap-3">
          <div className="h-px flex-1 bg-white/10" />
          <span className="text-xs font-bold uppercase tracking-[0.2em] text-white/40">vs</span>
          <div className="h-px flex-1 bg-white/10" />
        </div>

        {/* Contestant 2 */}
        <ContestantRow
          contestant={matchup.contestant2}
          isWinner={matchup.winner === matchup.contestant2.id}
          percentage={c2Percentage}
          canVote={matchup.isActive && !hasVoted && !isVoting}
          isVoting={isVoting}
          onVote={() => onVote(matchup.id, matchup.contestant2.id)}
        />

        {/* Vote Bar */}
        {totalVotes > 0 && (
          <div className="pt-2">
            <VoteBar
              segments={[
                { id: '1', label: matchup.contestant1.name, value: matchup.contestant1.votes },
                { id: '2', label: matchup.contestant2.name, value: matchup.contestant2.votes },
              ]}
              className="h-2"
            />
            <div className="mt-2 flex items-center justify-between text-xs text-white/50">
              <span>{matchup.contestant1.votes} votes</span>
              <span>{matchup.contestant2.votes} votes</span>
            </div>
          </div>
        )}
      </div>
    </Card>
  );
};

interface ContestantRowProps {
  contestant: TournamentMatchup['contestant1'];
  isWinner: boolean;
  percentage: number;
  canVote: boolean;
  isVoting: boolean;
  onVote: () => void;
}

const ContestantRow: React.FC<ContestantRowProps> = ({
  contestant,
  isWinner,
  percentage,
  canVote,
  isVoting,
  onVote,
}) => {
  return (
    <div className="flex items-center gap-3">
      {/* Avatar */}
      {contestant.imageUrl ? (
        <img
          src={contestant.imageUrl}
          alt={contestant.name}
          className="h-12 w-12 rounded-lg object-cover"
        />
      ) : (
        <div className="flex h-12 w-12 items-center justify-center rounded-lg bg-white/5">
          <Trophy className="h-6 w-6 text-white/40" />
        </div>
      )}

      {/* Info */}
      <div className="flex-1 min-w-0">
        <div className="flex items-center gap-2">
          <h4 className="truncate font-semibold text-white">{contestant.name}</h4>
          {isWinner && (
            <Trophy className="h-4 w-4 flex-shrink-0 text-[var(--hive-brand-primary)]" />
          )}
        </div>
        {contestant.description && (
          <p className="truncate text-sm text-white/60">{contestant.description}</p>
        )}
        {percentage > 0 && (
          <p className="text-xs text-white/50">{Math.round(percentage)}% of votes</p>
        )}
      </div>

      {/* Vote Button */}
      {canVote && (
        <Button
          size="sm"
          onClick={onVote}
          disabled={isVoting}
          className="flex-shrink-0 bg-white/10 hover:bg-white/20 text-white"
        >
          {isVoting ? 'Voting...' : 'Vote'}
        </Button>
      )}

      {isWinner && (
        <div className="flex h-8 w-8 flex-shrink-0 items-center justify-center rounded-full bg-[var(--hive-brand-primary)]">
          <Check className="h-5 w-5 text-black" />
        </div>
      )}
    </div>
  );
};

"use client";

import React, { useState, useCallback, useEffect, useRef } from "react";
import type {
  FeedPostType as PostType,
  CreatePostRequest,
  PostContent,
} from "@hive/core";
import { ContentProcessor, PostValidator } from "@hive/core";
import { Button } from "../ui/button";
import { Textarea } from "../ui/textarea";
import { Card } from "../ui/card";

import {
  Camera,
  Image,
  Video,
  Calendar,
  Users,
  BarChart3,
  Hash,
  AtSign,
  Link,
  Send,
  Globe,
  Lock,
  Eye,
} from "lucide-react";

/**
 * Post Editor Props
 */
export interface PostEditorProps {
  /** Post type being created */
  type: PostType;
  /** Current space context (optional) */
  spaceId?: string;
  spaceName?: string;
  /** Initial content for editing existing posts */
  initialContent?: Partial<CreatePostRequest>;
  /** Editor mode */
  mode: "inline" | "modal" | "expanded";
  /** Callback when post is submitted */
  onSubmit: (postData: CreatePostRequest) => Promise<void>;
  /** Callback when editor is closed */
  onClose?: () => void;
  /** Callback when content changes (for auto-save) */
  onChange?: (content: Partial<CreatePostRequest>) => void;
  /** Loading state */
  isSubmitting?: boolean;
  /** Error message */
  error?: string;
  /** Success callback */
  onSuccess?: () => void;
}

/**
 * Character count component with visual feedback
 */
const CharacterCount: React.FC<{
  current: number;
  max: number;
  type: PostType;
}> = ({ current, max, type }) => {
  const percentage = (current / max) * 100;
  const isNearLimit = percentage > 80;
  const isOverLimit = percentage > 100;

  return (
    <div className="flex items-center gap-2">
      <div className="relative w-6 h-6">
        <svg className="w-6 h-6 transform -rotate-90" viewBox="0 0 24 24">
          <circle
            cx="12"
            cy="12"
            r="10"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            className="text-muted-foreground/30"
          />
          <circle
            cx="12"
            cy="12"
            r="10"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeDasharray={`${2 * Math.PI * 10}`}
            strokeDashoffset={`${2 * Math.PI * 10 * (1 - percentage / 100)}`}
            className={
              isOverLimit
                ? "text-destructive"
                : isNearLimit
                  ? "text-amber-500"
                  : "text-primary"
            }
            style={{
              transition: "stroke-dashoffset 0.2s ease-in-out",
            }}
          />
        </svg>
      </div>
      <span
        className={`text-sm ${
          isOverLimit
            ? "text-destructive"
            : isNearLimit
              ? "text-amber-500"
              : "text-muted-foreground"
        }`}
      >
        {current}/{max}
      </span>
    </div>
  );
};

/**
 * Post type selector with tool configurations
 */
const PostTypeSelector: React.FC<{
  selectedType: PostType;
  onTypeChange: (type: PostType) => void;
  mode: "inline" | "modal" | "expanded";
}> = ({ selectedType, onTypeChange, mode }) => {
  const postTypes = [
    {
      type: "prompt-post" as PostType,
      label: "Prompt",
      icon: Hash,
      description: "Quick thought or question",
      charLimit: 500,
      available: ["inline", "modal", "expanded"],
    },
    {
      type: "pulse" as PostType,
      label: "Pulse",
      icon: BarChart3,
      description: "Status update",
      charLimit: 280,
      available: ["modal", "expanded"],
    },
    {
      type: "event-card" as PostType,
      label: "Event",
      icon: Calendar,
      description: "Announce an event",
      charLimit: 1000,
      available: ["modal", "expanded"],
    },
    {
      type: "join-form" as PostType,
      label: "Invite",
      icon: Users,
      description: "Invite to space",
      charLimit: 500,
      available: ["modal", "expanded"],
    },
    {
      type: "poll" as PostType,
      label: "Poll",
      icon: BarChart3,
      description: "Ask for opinions",
      charLimit: 300,
      available: ["modal", "expanded"],
    },
    {
      type: "media-post" as PostType,
      label: "Media",
      icon: Image,
      description: "Share photos/videos",
      charLimit: 1000,
      available: ["modal", "expanded"],
    },
  ];

  const availableTypes = postTypes.filter((type) =>
    type.available.includes(mode)
  );

  if (mode === "inline") {
    // Inline mode only shows PromptPost, no selector needed
    return null;
  }

  return (
    <div className="border-b border-border/50 p-4">
      <div className="flex gap-2 overflow-x-auto">
        {availableTypes.map(({ type, label, icon: Icon, description }) => (
          <Button
            key={type}
            variant={selectedType === type ? "primary" : "ghost"}
            size="sm"
            onClick={() => onTypeChange(type)}
            className="flex items-center gap-2 whitespace-nowrap"
          >
            <Icon className="w-4 h-4" />
            {label}
          </Button>
        ))}
      </div>
    </div>
  );
};

/**
 * Rich text content processing indicators
 */
const ContentIndicators: React.FC<{
  content: PostContent;
  onMentionClick?: (mention: string) => void;
  onHashtagClick?: (hashtag: string) => void;
}> = ({ content, onMentionClick, onHashtagClick }) => {
  const hasMentions = content.mentions && content.mentions.length > 0;
  const hasHashtags = content.hashtags && content.hashtags.length > 0;
  const hasLinks = content.links && content.links.length > 0;
  const hasMedia = content.media && content.media.length > 0;

  if (!hasMentions && !hasHashtags && !hasLinks && !hasMedia) {
    return null;
  }

  return (
    <div className="flex flex-wrap gap-2 p-2 bg-muted/30 rounded-md">
      {hasMentions && (
        <div className="flex items-center gap-1">
          <AtSign className="w-3 h-3 text-primary" />
          <span className="text-xs text-muted-foreground">
            {content.mentions!.length} mention
            {content.mentions!.length !== 1 ? "s" : ""}
          </span>
        </div>
      )}
      {hasHashtags && (
        <div className="flex items-center gap-1">
          <Hash className="w-3 h-3 text-primary" />
          <span className="text-xs text-muted-foreground">
            {content.hashtags!.length} tag
            {content.hashtags!.length !== 1 ? "s" : ""}
          </span>
        </div>
      )}
      {hasLinks && (
        <div className="flex items-center gap-1">
          <Link className="w-3 h-3 text-primary" />
          <span className="text-xs text-muted-foreground">
            {content.links!.length} link{content.links!.length !== 1 ? "s" : ""}
          </span>
        </div>
      )}
      {hasMedia && (
        <div className="flex items-center gap-1">
          <Image className="w-3 h-3 text-primary" />
          <span className="text-xs text-muted-foreground">
            {content.media!.length} media
          </span>
        </div>
      )}
    </div>
  );
};

/**
 * Visibility selector
 */
const VisibilitySelector: React.FC<{
  visibility: "public" | "space-only" | "followers-only";
  onChange: (visibility: "public" | "space-only" | "followers-only") => void;
  spaceId?: string;
  spaceName?: string;
}> = ({ visibility, onChange, spaceId, spaceName }) => {
  const options = [
    {
      value: "public" as const,
      label: "Public",
      icon: Globe,
      description: "Everyone can see this post",
    },
    {
      value: "space-only" as const,
      label: spaceName || "Space Only",
      icon: Lock,
      description: `Only ${spaceName || "space"} members can see this`,
      disabled: !spaceId,
    },
    {
      value: "followers-only" as const,
      label: "Followers",
      icon: Eye,
      description: "Only your followers can see this",
    },
  ];

  return (
    <div className="flex gap-1 p-1 bg-muted/50 rounded-md">
      {options.map(({ value, label, icon: Icon, disabled }) => (
        <Button
          key={value}
          variant={visibility === value ? "primary" : "ghost"}
          size="sm"
          onClick={() => onChange(value)}
          disabled={disabled}
          className="flex items-center gap-1 text-xs"
        >
          <Icon className="w-3 h-3" />
          {label}
        </Button>
      ))}
    </div>
  );
};

/**
 * Main Post Editor Component
 */
export const PostEditor: React.FC<PostEditorProps> = ({
  type,
  spaceId,
  spaceName,
  initialContent,
  mode,
  onSubmit,
  onClose,
  onChange,
  isSubmitting = false,
  error,
  onSuccess,
}) => {
  const [currentType, setCurrentType] = useState<PostType>(type);
  const [content, setContent] = useState(initialContent?.content?.text || "");
  const [visibility, setVisibility] = useState<
    "public" | "space-only" | "followers-only"
  >(initialContent?.visibility || (spaceId ? "space-only" : "public"));
  const [scheduledAt, setScheduledAt] = useState<Date | undefined>(
    initialContent?.scheduledAt
  );
  const [processedContent, setProcessedContent] = useState<PostContent>({});
  const [validation, setValidation] = useState<{
    valid: boolean;
    errors: string[];
  }>({ valid: true, errors: [] });

  const textareaRef = useRef<HTMLTextAreaElement>(null);

  // Character limits by post type
  const getCharLimit = (postType: PostType): number => {
    switch (postType) {
      case "prompt-post":
        return 500;
      case "pulse":
        return 280;
      case "event-card":
        return 1000;
      case "join-form":
        return 500;
      case "poll":
        return 300;
      case "media-post":
        return 1000;
      default:
        return 500;
    }
  };

  // Process content on text change
  useEffect(() => {
    if (content) {
      const processed = ContentProcessor.processContent(content);
      setProcessedContent({
        text: content,
        ...processed,
      });
    } else {
      setProcessedContent({ text: content });
    }
  }, [content]);

  // Validate content
  useEffect(() => {
    const validation = PostValidator.validateByType(
      currentType,
      processedContent
    );
    setValidation(validation);
  }, [currentType, processedContent]);

  // Auto-save / onChange callback
  useEffect(() => {
    if (onChange) {
      const postData: Partial<CreatePostRequest> = {
        type: currentType,
        content: {
          text: content || undefined,
          media: processedContent.media,
        },
        spaceId,
        visibility,
        scheduledAt,
      };
      onChange(postData);
    }
  }, [
    currentType,
    content,
    spaceId,
    visibility,
    scheduledAt,
    processedContent.media,
    onChange,
  ]);

  // Handle content change
  const handleContentChange = useCallback((value: string) => {
    setContent(value);
  }, []);

  // Handle submit
  const handleSubmit = useCallback(async () => {
    if (!validation.valid || isSubmitting) return;

    const postData: CreatePostRequest = {
      type: currentType,
      content: {
        text: content || undefined,
        media: processedContent.media,
      },
      spaceId,
      visibility,
      scheduledAt,
    };

    try {
      await onSubmit(postData);
      onSuccess?.();
    } catch (err) {
      // Error handled by parent
    }
  }, [
    currentType,
    content,
    processedContent.media,
    spaceId,
    visibility,
    scheduledAt,
    validation.valid,
    isSubmitting,
    onSubmit,
    onSuccess,
  ]);

  // Handle keyboard shortcuts
  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (e.key === "Enter" && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        handleSubmit();
      } else if (e.key === "Escape" && onClose) {
        e.preventDefault();
        onClose();
      }
    },
    [handleSubmit, onClose]
  );

  const charLimit = getCharLimit(currentType);
  const isOverLimit = content.length > charLimit;
  const canSubmit =
    validation.valid &&
    !isOverLimit &&
    !isSubmitting &&
    content.trim().length > 0;

  return (
    <Card
      className={`${
        mode === "inline"
          ? "border-none shadow-none bg-transparent"
          : "border shadow-lg"
      }`}
    >
      <PostTypeSelector
        selectedType={currentType}
        onTypeChange={setCurrentType}
        mode={mode}
      />

      <div className="p-4 space-y-4">
        {/* Main content area */}
        <div className="space-y-3">
          <Textarea
            ref={textareaRef}
            value={content}
            onChange={(e) => handleContentChange(e.target.value)}
            onKeyDown={handleKeyDown}
            placeholder={
              currentType === "prompt-post"
                ? "What's on your mind?"
                : currentType === "pulse"
                  ? "How are you feeling?"
                  : currentType === "event-card"
                    ? "What's happening?"
                    : currentType === "join-form"
                      ? "Invite people to join..."
                      : currentType === "poll"
                        ? "Ask a question..."
                        : currentType === "media-post"
                          ? "Share a photo or video..."
                          : "Start typing..."
            }
            className={`min-h-[100px] resize-none border-none bg-transparent text-base ${
              mode === "inline" ? "text-sm" : ""
            }`}
            disabled={isSubmitting}
          />

          {/* Content indicators */}
          <ContentIndicators content={processedContent} />

          {/* Validation errors */}
          {!validation.valid && (
            <div className="text-sm text-destructive">
              {validation.errors.map((error, index) => (
                <div key={index}>{error}</div>
              ))}
            </div>
          )}
        </div>

        {/* Editor controls */}
        <div className="flex items-center justify-between gap-4">
          {/* Left side - formatting and media controls */}
          <div className="flex items-center gap-2">
            {(mode === "modal" || mode === "expanded") && (
              <>
                <Button variant="ghost" size="sm" disabled>
                  <Camera className="w-4 h-4" />
                </Button>
                <Button variant="ghost" size="sm" disabled>
                  <Video className="w-4 h-4" />
                </Button>
                {currentType === "event-card" && (
                  <Button variant="ghost" size="sm" disabled>
                    <Calendar className="w-4 h-4" />
                  </Button>
                )}
              </>
            )}
          </div>

          {/* Right side - visibility, character count, and submit */}
          <div className="flex items-center gap-3">
            {(mode === "modal" || mode === "expanded") && (
              <VisibilitySelector
                visibility={visibility}
                onChange={setVisibility}
                spaceId={spaceId}
                spaceName={spaceName}
              />
            )}

            <CharacterCount
              current={content.length}
              max={charLimit}
              type={currentType}
            />

            <Button
              onClick={handleSubmit}
              disabled={!canSubmit}
              size={mode === "inline" ? "sm" : "default"}
              className="flex items-center gap-2"
            >
              {isSubmitting ? (
                <div className="w-4 h-4 animate-spin border-2 border-current border-t-transparent rounded-full" />
              ) : (
                <Send className="w-4 h-4" />
              )}
              {mode === "inline" ? "Post" : "Publish"}
            </Button>
          </div>
        </div>

        {/* Error display */}
        {error && (
          <div className="text-sm text-destructive bg-destructive/10 p-3 rounded-md">
            {error}
          </div>
        )}
      </div>
    </Card>
  );
};

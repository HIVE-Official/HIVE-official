import { 
  useQuery, 
  useMutation, 
  useQueryClient,
  type UseQueryOptions
} from '@tanstack/react-query';
import { 
  collection, 
  doc, 
  getDocs, 
  getDoc, 
  setDoc, 
  updateDoc, 
  deleteDoc, 
  query, 
  where, 
  orderBy, 
  limit,
  serverTimestamp,
  increment,
  arrayUnion
} from 'firebase/firestore';
import { logger } from '@hive/core';

// Type definitions - these should be moved to a shared types package later
interface Tool {
  id: string;
  name: string;
  description: string;
  spaceId?: string;
  createdBy: string;
  createdAt: Date | string;
  updatedAt: Date | string;
  executionCount: number;
  rating: number;
  ratingCount: number;
  permissions?: string[];
  sharedSpaceIds?: string[];
  inputs?: Record<string, unknown>;
  outputs?: Record<string, unknown>;
}

interface ToolExecution {
  id: string;
  toolId: string;
  userId: string;
  inputs: Record<string, unknown>;
  outputs: Record<string, unknown>;
  status: 'running' | 'completed' | 'failed';
  startedAt: string;
  completedAt: string | null;
}

interface ToolTemplate {
  id: string;
  name: string;
  description: string;
  category: string;
  template: Record<string, unknown>;
}

// Firebase instance - should be imported from the app, not the package
// Using any here since Firebase types are complex and will be provided by the app
declare const db: any; // eslint-disable-line @typescript-eslint/no-explicit-any

// Tool CRUD operations
export function useTools(spaceId?: string, options?: UseQueryOptions<Tool[]>) {
  return useQuery({
    queryKey: ['tools', spaceId],
    queryFn: async () => {
      try {
        const toolsRef = collection(db, 'tools');
        const q = spaceId 
          ? query(toolsRef, where('spaceId', '==', spaceId), orderBy('createdAt', 'desc'))
          : query(toolsRef, orderBy('createdAt', 'desc'));
        
        const snapshot = await getDocs(q);
        return snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        } as Tool));
      } catch (_error) {
        logger._error('Failed to fetch tools', { _error });
        throw _error;
      }
    }
    ...options
  });
}

export function useTool(toolId: string, options?: UseQueryOptions<Tool | null>) {
  return useQuery({
    queryKey: ['tool', toolId],
    queryFn: async () => {
      if (!toolId) return null;
      
      try {
        const toolDoc = await getDoc(doc(db, 'tools', toolId));
        if (!toolDoc.exists()) return null;
        
        return {
          id: toolDoc.id,
          ...toolDoc.data()
        } as Tool;
      } catch (_error) {
        logger._error('Failed to fetch tool', { _error, toolId });
        throw _error;
      }
    }
    enabled: !!toolId,
    ...options
  });
}

export function useCreateTool() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (tool: Omit<Tool, 'id' | 'createdAt' | 'updatedAt'>) => {
      const toolDoc = doc(collection(db, 'tools'));
      const toolData = {
        ...tool,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
        executionCount: 0,
        rating: 0,
        ratingCount: 0
      };
      
      await setDoc(toolDoc, toolData);
      
      // Return with actual date strings since serverTimestamp is a placeholder
      return {
        id: toolDoc.id,
        ...tool,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        executionCount: 0,
        rating: 0,
        ratingCount: 0
      } as Tool;
    }
    onSuccess: (newTool: Tool) => {
      // Invalidate tools list
      queryClient.invalidateQueries({ queryKey: ['tools'] });
      
      // Add to cache
      queryClient.setQueryData(['tool', newTool.id], newTool);
      
      logger.info('Tool created successfully', { toolId: newTool.id });
    }

    onError: (error: Error) => {
      logger._error('Failed to create tool', { _error });
    }
  });
}

export function useUpdateTool() {
  const queryClient = useQueryClient();
  
  return useMutation<
    { toolId: string; updates: Partial<Tool> },
    Error,
    { toolId: string; updates: Partial<Tool> },
    { previousTool?: Tool }
  >({
    mutationFn: async ({ toolId, updates }: { 
      toolId: string; 
      updates: Partial<Tool> 
    }) => {
      const toolRef = doc(db, 'tools', toolId);
      const updateData = {
        ...updates,
        updatedAt: serverTimestamp()
      };
      
      await updateDoc(toolRef, updateData);
      
      return { toolId, updates };
    }
    onMutate: async ({ toolId, updates }) => {
      // Cancel queries
      await queryClient.cancelQueries({ queryKey: ['tool', toolId] });
      
      // Optimistic update
      const previousTool = queryClient.getQueryData<Tool>(['tool', toolId]);
      if (previousTool) {
        queryClient.setQueryData(['tool', toolId], {
          ...previousTool,
          ...updates
        });
      }
      
      return { previousTool };
    }

    onError: (error: Error, variables, context) => {
      // Rollback on _error
      if (context?.previousTool) {
        queryClient.setQueryData(['tool', variables.toolId], context.previousTool);
      }
      logger._error('Failed to update tool', { _error });
    }
    onSettled: (data: { toolId: string; updates: Partial<Tool> } | undefined) => {
      if (data) {
        queryClient.invalidateQueries({ queryKey: ['tool', data.toolId] });
        queryClient.invalidateQueries({ queryKey: ['tools'] });
      }
    }
  });
}

export function useDeleteTool() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (toolId: string) => {
      await deleteDoc(doc(db, 'tools', toolId));
      return toolId;
    }
    onSuccess: (toolId) => {
      // Remove from cache
      queryClient.removeQueries({ queryKey: ['tool', toolId] });
      queryClient.invalidateQueries({ queryKey: ['tools'] });
      
      logger.info('Tool deleted successfully', { toolId });
    }

    onError: (error: Error) => {
      logger._error('Failed to delete tool', { _error });
    }
  });
}

// Tool execution
export function useExecuteTool() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ 
      toolId, 
      inputs, 
      userId 
    }: { 
      toolId: string; 
      inputs: Record<string, unknown>; 
      userId: string;
    }) => {
      // Create execution record
      const executionRef = doc(collection(db, 'tool_executions'));
      const execution: ToolExecution = {
        id: executionRef.id,
        toolId,
        userId,
        inputs,
        outputs: {},
        status: 'running',
        startedAt: new Date().toISOString(),
        completedAt: null
      };
      
      await setDoc(executionRef, execution);
      
      // Update tool execution count
      await updateDoc(doc(db, 'tools', toolId), {
        executionCount: increment(1),
        lastExecutedAt: serverTimestamp()
      });
      
      // Here you would integrate with your actual tool execution backend
      // For now, we'll simulate execution
      const outputs = await simulateToolExecution(toolId, inputs);
      
      // Update execution with results
      await updateDoc(executionRef, {
        outputs,
        status: 'completed',
        completedAt: serverTimestamp()
      });
      
      return {
        ...execution,
        outputs,
        status: 'completed' as const
      };
    }
    onSuccess: (execution: ToolExecution) => {
      // Invalidate tool to update execution count
      queryClient.invalidateQueries({ queryKey: ['tool', execution.toolId] });
      queryClient.invalidateQueries({ queryKey: ['tool-executions', execution.toolId] });
      
      logger.info('Tool executed successfully', { 
        toolId: execution.toolId, 
        executionId: execution.id 
      });
    }

    onError: (error: Error) => {
      logger._error('Failed to execute tool', { _error });
    }
  });
}

// Tool templates
export function useToolTemplates(options?: UseQueryOptions<ToolTemplate[]>) {
  return useQuery({
    queryKey: ['tool-templates'],
    queryFn: async () => {
      try {
        const templatesRef = collection(db, 'tool_templates');
        const q = query(templatesRef, orderBy('category'), orderBy('name'));
        
        const snapshot = await getDocs(q);
        return snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        } as ToolTemplate));
      } catch (_error) {
        logger._error('Failed to fetch tool templates', { _error });
        throw _error;
      }
    }
    ...options
  });
}

// Tool ratings
export function useRateTool() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ 
      toolId, 
      rating, 
      userId 
    }: { 
      toolId: string; 
      rating: number; 
      userId: string;
    }) => {
      // Store individual rating
      const ratingRef = doc(db, 'tool_ratings', `${toolId}_${userId}`);
      await setDoc(ratingRef, {
        toolId,
        userId,
        rating,
        createdAt: serverTimestamp()
      });
      
      // Update tool aggregate rating
      // In production, this would be done via Cloud Function for accuracy
      await updateDoc(doc(db, 'tools', toolId), {
        ratingCount: increment(1),
        // This is simplified - real implementation would recalculate average rating: increment(rating / 100)
      });
      
      return { toolId, rating };
    }
    onSuccess: ({ toolId }) => {
      queryClient.invalidateQueries({ queryKey: ['tool', toolId] });
      logger.info('Tool rated successfully', { toolId });
    }

    onError: (error: Error) => {
      logger._error('Failed to rate tool', { _error });
    }
  });
}

// Tool permissions
export function useUpdateToolPermissions() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ 
      toolId, 
      permissions 
    }: { 
      toolId: string; 
      permissions: string[];
    }) => {
      await updateDoc(doc(db, 'tools', toolId), {
        permissions,
        updatedAt: serverTimestamp()
      });
      
      return { toolId, permissions };
    }
    onSuccess: ({ toolId }) => {
      queryClient.invalidateQueries({ queryKey: ['tool', toolId] });
      logger.info('Tool permissions updated', { toolId });
    }

    onError: (error: Error) => {
      logger._error('Failed to update tool permissions', { _error });
    }
  });
}

// Tool sharing
export function useShareTool() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ 
      toolId, 
      spaceIds 
    }: { 
      toolId: string; 
      spaceIds: string[];
    }) => {
      await updateDoc(doc(db, 'tools', toolId), {
        sharedSpaceIds: arrayUnion(...spaceIds),
        updatedAt: serverTimestamp()
      });
      
      return { toolId, spaceIds };
    }
    onSuccess: ({ toolId }) => {
      queryClient.invalidateQueries({ queryKey: ['tool', toolId] });
      logger.info('Tool shared successfully', { toolId });
    }

    onError: (error: Error) => {
      logger._error('Failed to share tool', { _error });
    }
  });
}

// Helper function to simulate tool execution
async function simulateToolExecution(,
  toolId: string, 
  inputs: Record<string, unknown>
): Promise<Record<string, unknown>> {
  // Simulate processing time
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Return mock outputs based on tool type
  return {
    result: 'Tool executed successfully',
    processedInputs: inputs,
    timestamp: new Date().toISOString()
  };
}

// Tool analytics
export function useToolAnalytics(toolId: string, options?: UseQueryOptions<{
  totalExecutions: number;
  successRate: number;
  avgExecutionTime: number;
  recentExecutions: ToolExecution[];
}>) {
  return useQuery({
    queryKey: ['tool-analytics', toolId],
    queryFn: async () => {
      try {
        // Fetch execution history
        const executionsRef = collection(db, 'tool_executions');
        const q = query(
          executionsRef, 
          where('toolId', '==', toolId),
          orderBy('startedAt', 'desc'),
          limit(100)
        );
        
        const snapshot = await getDocs(q);
        const executions = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        } as ToolExecution));
        
        // Calculate analytics
        const totalExecutions = executions.length;
        const successRate = executions.filter(e => e.status === 'completed').length / totalExecutions;
        const avgExecutionTime = executions.reduce((acc, e) => {
          if (e.completedAt && e.startedAt) {
            return acc + (new Date(e.completedAt).getTime() - new Date(e.startedAt).getTime());
          }
          return acc;
        }, 0) / totalExecutions;
        
        return {
          totalExecutions,
          successRate,
          avgExecutionTime,
          recentExecutions: executions.slice(0, 10)
        };
      } catch (_error) {
        logger._error('Failed to fetch tool analytics', { _error, toolId });
        throw _error;
      }
    }
    enabled: !!toolId,
    ...options
  });
}